import { useChatInfo } from '@/context/ChatInfoContext'; // Assuming correct path
import { UserButton, useUser } from '@clerk/clerk-react'; // Added useUser for user info
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { BsEmojiSmile } from 'react-icons/bs';
import { FaCheckDouble } from 'react-icons/fa';
import {
  FiAlertTriangle,
  FiCopy,
  FiGlobe,
  FiPaperclip,
  FiRefreshCw,
  FiSend,
  FiZap,
} from 'react-icons/fi';
import { toast } from 'sonner';
import { generateGeminiResponse } from '../../../../service/AIModal'; // Adjust import path
import GlobalApi from '../../../../service/GlobalApi'; // Adjust import path
import SquareLoade from "./chatLoding";
import Loader from './loder'; // Adjust import path
import TypewriterText from './TypewriterText'; // Import the new component

// --- Interfaces & Types ---

interface InfoCardProps {
  icon: React.ReactNode;
  title: string;
  description: string;
  bgColorClass: string;
  textColorClass: string;
}

type MessageType = 'text'; // Add other types like 'image' if needed

interface MessageAction {
  type: 'speak' | 'copy' | 'regenerate' | 'thumbsDown';
  icon: React.ReactNode;
  // Add onClick handler if needed directly here or handle in the component
}

// Type for messages used INTERNALLY in the component
type UIMessage = {
  msgid: string | number; // Use string for consistency with potential backend IDs
  sender: 'user' | 'bot';
  senderName?: string; // Optional: For displaying user/bot name/avatar
  avatarUrl?: string; // Optional: For user/bot avatar
  type: MessageType;
  content: string;
  timestamp: Date;
  actions?: MessageAction[];
  isTyping?: boolean; // To handle the typewriter effect state per message
};

// Type matching the backend structure (as fetched by context)
type BackendChatMessage = {
  id: number; // Or string, adjust if needed based on backend
  msgid: string; // Keep if backend uses this specifically
  sender: "user" | "bot";
  type: MessageType;
  content: string;
  timestamp: string; // Comes as string from backend
};


// --- Helper Functions ---
const formatTime = (date: Date | string): string => {
  try {
    const d = typeof date === 'string' ? new Date(date) : date;
    if (isNaN(d.getTime())) { // Check if date is valid
      return "Invalid Date";
    }
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
  } catch (e) {
    console.error("Error formatting time:", e, "Input:", date);
    return "--:--";
  }
};

// --- Reusable Components ---
const InfoCard: React.FC<InfoCardProps> = ({ icon, title, description, bgColorClass, textColorClass }) => {
  // ... (keep existing InfoCard implementation)
  return (
    <div className={`flex flex-col items-start p-4 rounded-lg ${bgColorClass} w-full md:w-1/3 transition-all duration-200 hover:shadow-md`}>
      <div className={`text-lg mb-2 ${textColorClass}`}>
        {icon}
      </div>
      <h3 className={`font-semibold mb-1 ${textColorClass}`}>{title}</h3>
      <p className={`text-sm ${textColorClass} opacity-80`}>{description}</p>
    </div>
  );
};

// --- Formatting Function ---
const renderTextMessageContent = (content: string): React.ReactNode => {
  // ... (keep existing renderTextMessageContent implementation)
  if (typeof content !== 'string') {
    return null;
  }
  return (
    <div className="whitespace-pre-wrap text-sm">
      {content.split('\n').map((line: string, index: number) => (
        <React.Fragment key={index}>
          {line.split('**').map((part, partIndex) =>
            partIndex % 2 === 1 ? <strong key={partIndex}>{part}</strong> : part
          )}
          {/* Add line break unless it's the very last empty line */}
          {(index < content.split('\n').length - 1 || line.length > 0) && <br />}
        </React.Fragment>
      ))}
    </div>
  );
};


// --- Data Transformation Helpers ---

// Convert backend message structure to UI message structure
const transformBackendToUI = (msg: BackendChatMessage): UIMessage => ({
  msgid: msg.msgid || `backend-${msg.id}`, // Use msgid if available, fallback to id
  sender: msg.sender,
  type: msg.type,
  content: msg.content,
  timestamp: new Date(msg.timestamp), // Convert string to Date
  // Add default actions for bot messages if needed
  actions: msg.sender === 'bot' ? [
    { type: 'copy', icon: <FiCopy size={16} /> },
    { type: 'regenerate', icon: <FiRefreshCw size={16} /> },
  ] : undefined,
});

// Convert UI message structure back to backend message structure (if necessary for update API)
// Adjust this based on EXACTLY what your UpdateChatDetail API expects
const transformUIToBackend = (msg: UIMessage): Omit<BackendChatMessage, 'id'> => ({
  // id might be generated by backend, so often omitted or handled differently in updates
  msgid: String(msg.msgid), // Ensure msgid is string if backend expects it
  sender: msg.sender,
  type: msg.type,
  content: msg.content,
  timestamp: msg.timestamp.toISOString(), // Convert Date back to ISO string
});


// --- Main Merged Chat Interface Component ---

const ChatInterface: React.FC = () => {
  const { selectedChat, ChatContent, setChatContent } = useChatInfo();
  const { user } = useUser(); // Get user info for avatar/name

  // State Management
  const [messages, setMessages] = useState<UIMessage[]>([]); // Holds UI-formatted messages
  const [inputValue, setInputValue] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [isLoading, setIsLoading] = useState(false);
  // Removed isBotTyping state - will manage via message property

  // --- Effect to Sync with Context ---
  useEffect(() => {
    console.log("ChatContent from context:", ChatContent); // Debug log
    if (ChatContent && Array.isArray(ChatContent)) {
      try {
        const uiMessages = ChatContent.map(transformBackendToUI);
        setMessages(uiMessages);
      } catch (error) {
        console.error("Error transforming backend chat content:", error);
        toast.error("Failed to load chat history correctly.");
        setMessages([]); // Reset on error
      }
    } else if (!selectedChat) {
      // Explicitly clear messages if no chat is selected
      setMessages([]);
    }
    // Clear input when chat changes
    setInputValue('');
    const textarea = document.querySelector('textarea');
    if (textarea) {
      textarea.style.height = 'auto'; // Reset height
    }
  }, [ChatContent, selectedChat]); // Re-run when context data or selected chat changes

  // Scroll to bottom
  useEffect(() => {
    // Add a small delay to allow rendering layout adjustments
    const timer = setTimeout(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, 100);
    return () => clearTimeout(timer);
  }, [messages]); // Scroll when messages array changes

  // --- Event Handlers ---

  const handleInputChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInputValue(event.target.value);
    // Auto-resize textarea
    event.target.style.height = 'auto';
    event.target.style.height = `${Math.min(event.target.scrollHeight, 160)}px`; // Max height 10rem (160px)
  };

  const handleSend = useCallback(async () => {
    const trimmedInput = inputValue.trim();
    if (trimmedInput === '' || isLoading || !selectedChat) {
      if (!selectedChat) toast.error("Please select a chat first.");
      return; // Prevent sending empty, while loading, or if no chat selected
    }

    setIsLoading(true);
    setInputValue(''); // Clear input immediately

    // Reset textarea height
    const textarea = document.querySelector('textarea');
    if (textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = '2.5rem'; // Reset to default row=1 height
    }

    const newUserMessage: UIMessage = {
      msgid: `local-${Date.now()}`, // Temporary local ID
      sender: 'user',
      type: 'text',
      content: trimmedInput,
      timestamp: new Date(),
      senderName: user?.fullName || user?.primaryEmailAddress?.emailAddress || 'User',
      avatarUrl: user?.imageUrl,
    };

    // --- Optimistic UI Update ---
    // Add user message immediately AND add a placeholder for the bot response
    const botPlaceholderMessage: UIMessage = {
      msgid: `local-${Date.now() + 1}`,
      sender: 'bot',
      type: 'text',
      content: '', // Empty content initially
      timestamp: new Date(),
      isTyping: true, // Indicate bot is "typing"
    };
    const messagesWithUserAndPlaceholder = [...messages, newUserMessage, botPlaceholderMessage];
    setMessages(messagesWithUserAndPlaceholder); // Update UI


    try {
      // --- Actual API Call ---
      const responseText = await generateGeminiResponse(trimmedInput);

      const newBotMessage: UIMessage = {
        ...botPlaceholderMessage, // Use placeholder ID and timestamp
        content: responseText,
        isTyping: false, // Typing finished
        actions: [ // Add actions now that content is available
          { type: 'copy', icon: <FiCopy size={16} /> },
          { type: 'regenerate', icon: <FiRefreshCw size={16} /> },
        ]
      };

      // Replace placeholder with the actual bot message
      const finalMessages = messagesWithUserAndPlaceholder.map(msg =>
        msg.msgid === botPlaceholderMessage.msgid ? newBotMessage : msg
      );
      setMessages(finalMessages); // Update UI with final bot message

      // --- Prepare data for Backend Update ---
      // Map ALL messages (including new ones) back to the backend format
      const updatedBackendMessages = finalMessages.map(transformUIToBackend);

      const updatePayload = {
        data: {
          // Ensure this structure matches what your Strapi/backend expects
          chatContent: updatedBackendMessages
        }
      };

      // --- Update Backend and Context ---
      await GlobalApi.UpdateChatDetail(selectedChat, updatePayload); // Assuming selectedChat has an 'id'
      toast.success('Chat saved!');

      // --- Update Context State ---
      // It's crucial that setChatContent receives data in the *backend* format
      // We assume the backend returns the updated list or confirms the sent data
      // For simplicity, we update context with what we *sent* to the backend
      setChatContent(updatedBackendMessages);


    } catch (error: any) {
      console.error("Failed to get response or update chat:", error);
      const errorMessageContent = error?.message || "Sorry, an error occurred fetching the response.";

      // Replace placeholder with an error message
      const errorBotMessage: UIMessage = {
        ...botPlaceholderMessage, // Use placeholder ID and timestamp
        content: `⚠️ ${errorMessageContent}`,
        isTyping: false, // Typing finished (with error)
      };
      const finalMessagesWithError = messagesWithUserAndPlaceholder.map(msg =>
        msg.msgid === botPlaceholderMessage.msgid ? errorBotMessage : msg
      );
      setMessages(finalMessagesWithError); // Update UI with error message

      toast.error("Failed to get AI response or save chat.");
      // Optionally: Revert context if persistence failed? Depends on desired behavior.
      // If the API call failed, the context wasn't updated yet, so maybe no action needed there.
    } finally {
      setIsLoading(false); // Stop loading indicator
    }
  }, [inputValue, isLoading, selectedChat, messages, user, setChatContent]); // Dependencies for the callback

  const handleKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      handleSend();
    }
  };

  // --- Action Handlers (Example: Copy) ---
  const handleMessageAction = (actionType: MessageAction['type'], messageContent: string) => {
    if (actionType === 'copy') {
      navigator.clipboard.writeText(messageContent)
        .then(() => toast.success("Copied to clipboard!"))
        .catch(err => toast.error("Failed to copy text."));
    } else if (actionType === 'regenerate') {
      toast.info("Regenerate functionality not implemented yet.");
      // You would need to find the *previous* user message and resubmit it
      // This requires more complex state management or message structure (e.g., linking responses to prompts)
    }
    // Add other action handlers (speak, thumbsDown)
  };

  // --- Main Component Return ---
  return (
    <div className="flex flex-col items-center justify-between min-h-screen bg-white dark:bg-gray-900 p-4 md:p-8 w-full md:w-[calc(100vw-300px)] lg:w-[calc(100vw-400px)] mx-auto"> {/* Adjust width based on sidebar */}

      {/* Conditional Display: Welcome Screen or Chat History */}
      {/* Show welcome if no chat is selected OR if a chat is selected but has no messages AND isn't loading */}
      {(!selectedChat || (messages.length === 0)) && !isLoading ? (
        // Welcome Screen
        <div className="flex flex-col items-center w-full max-w-4xl flex-grow mt-10 md:mt-20 text-center px-4">
          <div className="mb-4">
            <span className="bg-purple-100 text-purple-700 dark:bg-purple-900 dark:text-purple-300 text-sm font-semibold px-3 py-1 rounded-md">
              CHAT A.I+
            </span>
          </div>
          <h1 className="text-3xl md:text-4xl font-semibold text-gray-800 dark:text-gray-100 mb-10">
            {selectedChat ? "Start chatting!" : "Select a chat or start a new one"}
          </h1>
          {/* Only show info cards if no chat is selected */}
          {selectedChat && (
            <div className="flex flex-col md:flex-row gap-4 w-full max-w-3xl mb-12">
              <InfoCard
                icon={<FiGlobe />}
                title="Explore"
                description="Discover new tools and concepts"
                bgColorClass="bg-blue-100 dark:bg-blue-900"
                textColorClass="text-blue-800 dark:text-blue-200"
              />
              <InfoCard
                icon={<FiZap />}
                title="Capabilities"
                description="Fast and intelligent responses"
                bgColorClass="bg-purple-100 dark:bg-purple-900"
                textColorClass="text-purple-800 dark:text-purple-200"
              />
              <InfoCard
                icon={<FiAlertTriangle />}
                title="Limitation"
                description="May occasionally produce incorrect info"
                bgColorClass="bg-yellow-100 dark:bg-yellow-900"
                textColorClass="text-yellow-800 dark:text-yellow-200"
              />
            </div>
          )}
        </div>
      ) : (
        // Chat History Area
        <div className="flex-grow overflow-y-auto p-4 space-y-6 w-full max-w-5xl mb-4 scrollbar-thin scrollbar-thumb-gray-300 dark:scrollbar-thumb-gray-600 scrollbar-track-gray-100 dark:scrollbar-track-gray-800">
          {messages.map((message) => (
            <div
              key={message.msgid}
              className={`flex items-end space-x-2 ${message.sender === 'user' ? 'justify-end' : 'justify-start'}`}
            >
              {/* Bot Avatar */}
              {message.sender === 'bot' && (
                <div className="flex-shrink-0 w-8 h-8 rounded-full bg-indigo-200 dark:bg-indigo-800 text-indigo-700 dark:text-indigo-200 flex items-center justify-center font-semibold text-sm self-start">
                  AI+
                </div>
              )}

              {/* Message Bubble */}
              <div
                className={`max-w-lg lg:max-w-xl px-3 py-2 rounded-lg shadow-sm ${message.sender === 'user'
                  ? 'bg-blue-600 text-white rounded-br-none'
                  : 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-100 border border-gray-200 dark:border-gray-600 rounded-bl-none'
                  }`}
              >
                {/* Handle Bot Typing Placeholder or Actual Content */}
                {message.sender === 'bot' && message.isTyping ? (
                  <Loader /> // Show loader while bot "types"
                ) : message.sender === 'bot' ? (
                  <TypewriterText
                    text={message.content}
                    renderContent={renderTextMessageContent} // Pass the formatter
                  // No need for onComplete here as we manage typing state via message prop
                  />
                ) : (
                  // Render user message content directly
                  renderTextMessageContent(message.content)
                )}

                {/* Timestamp and Checkmark */}
                <div className={`text-xs mt-1 flex items-center ${message.sender === 'user' ? 'justify-end text-blue-200 dark:text-blue-300' : 'justify-end text-gray-400 dark:text-gray-500'}`}>
                  <span>{formatTime(message.timestamp)}</span>
                  {message.sender === 'user' && <FaCheckDouble size={12} className="ml-1" />}
                </div>

                {/* Bot Actions (Show only if not typing and actions exist) */}
                {message.sender === 'bot' && !message.isTyping && message.actions && (
                  <div className="mt-2 pt-2 border-t border-gray-200 dark:border-gray-600 flex items-center space-x-3">
                    {message.actions.map(action => (
                      <button
                        key={action.type}
                        className="text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300 transition-colors"
                        title={action.type.charAt(0).toUpperCase() + action.type.slice(1).replace(/([A-Z])/g, ' $1').trim()}
                        onClick={() => handleMessageAction(action.type, message.content)}
                      >
                        {action.icon}
                      </button>
                    ))}
                  </div>
                )}
              </div>

              {/* User Avatar */}
              {message.sender === 'user' && (
                <div className="flex-shrink-0 w-8 h-8">
                  <UserButton afterSignOutUrl="/" />
                </div>
              )}
            </div>
          ))}

          {/* --- LOADING INDICATOR (for initial load or explicit loading states) --- */}
          {isLoading && messages.length === 0 && ( // Show only if loading AND messages are empty (initial load)
            <div className="flex justify-center mt-4"><Loader /></div>
          )}

          {/* Invisible element to scroll to */}
          <div ref={messagesEndRef} />
        </div>
      )}

      {/* Input Area */}
      {selectedChat && ( // Only show input area if a chat is selected
        <div className="w-full max-w-5xl sticky bottom-0 bg-gray-50 dark:bg-gray-900 pb-4 pt-2 px-4">
          <div className="relative flex items-end bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-xl shadow-sm p-2">
            <button className="p-2 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-400 self-center mb-1 hidden sm:block"> {/* Hide on small screens */}
              <FiPaperclip size={20} />
            </button>
            <button className="p-2 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-400 self-center mb-1 hidden sm:block"> {/* Hide on small screens */}
              <BsEmojiSmile size={20} />
            </button>
            <textarea
              rows={1}
              className="flex-grow resize-none border-none focus:ring-0 outline-none p-2 text-sm text-gray-700 dark:text-gray-200 placeholder-gray-400 dark:placeholder-gray-500 bg-transparent mx-1 scrollbar-thin scrollbar-thumb-gray-300 dark:scrollbar-thumb-gray-600 scrollbar-track-transparent"
              placeholder="Enter your prompt..."
              value={inputValue}
              onChange={handleInputChange}
              onKeyDown={handleKeyDown}
              disabled={isLoading || !selectedChat} // Disable input while loading or if no chat selected
              style={{ minHeight: '2.5rem', maxHeight: '10rem' }} // min-h-10
            />
            <button
              className={`p-2 rounded-lg ml-1 transition-colors self-end mb-1 ${inputValue.trim() && !isLoading
                ? 'bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800'
                : 'bg-gray-200 dark:bg-gray-600 text-gray-400 dark:text-gray-500 cursor-not-allowed'
                }`}
              disabled={!inputValue.trim() || isLoading || !selectedChat}
              onClick={handleSend}
              title="Send message"
            >
              {!isLoading ? <FiSend size={20} /> : <SquareLoade />}
            </button>
          </div>
          <p className="text-xs text-gray-500 dark:text-gray-400 text-center mt-2">
            {isLoading ? 'Generating response...' : (selectedChat ? 'Shift+Enter for newline.' : 'Select a chat to begin.')}
          </p>
        </div>
      )}
    </div>
  );
};

export default ChatInterface;